# Author: Prof. Fitzsimmons 
# Filname: tictactoe.py
#
# Description: Starter code for an implementation of the game
# Tic-Tac-Toe with a computer player that uses minimax with
# or without alpha-beta pruning to compute its moves.

import sys

# Prints the given board to standard output
def printBoard(board):
    for i in range(len(board)): #rows
        for j in range(len(board[0])-1): #columns
            print("%s," %board[i][j],end="")
        print("%s" %board[i][len(board[0])-1])

# Returns the winner and the evaluation of the
# board given as a parameter, i.e., returns
# 1,'X' or -1,'O' when there is a winner
# 0,'No one' for a tie and 0,'?' otherwise
def TerminalTest(board):
    # Check each row
    for i in range(len(board)):
        if(board[i][0] == board[i][1] and
           board[i][0] == board[i][2]):
            if(board[i][0] == 'X'):
                return 1,'X'
            elif(board[i][0] == 'O'):
                return -1,'O'
    # Check each column
    for j in range(len(board[0])):
        if(board[0][j] == board[1][j] and
           board[0][j] == board[2][j]):
            if(board[0][j] == 'X'):
                return 1,'X'
            elif(board[0][j] == 'O'):
                return -1,'O'

    # Check each diagonal
    if(board[0][0] == board[1][1] and
       board[0][0] == board[2][2]): 
        if (board[0][0] == 'X'):
            return 1,'X'
        elif (board[0][0] == 'O'):
            return -1,'O'

    if(board[0][2] == board[1][1] and
       board[0][2] == board[2][0]):
        if (board[0][2] == 'X'):
            return 1,'X'
        elif (board[0][2] == 'O'):
            return -1,'O'

    for i in range(len(board)):
        for j in range(len(board[0])):
            if (board[i][j] == '-'):
                return 0,'?'

    return 0,'No one'

# Returns the best move for X, the value of that move, and the number of search nodes generated.
def MaxValue(current, prune, alpha, beta):
    
    score = TerminalTest(current)[0] # first arg of TerminalTest is the score
    winner = TerminalTest(current)[1]  # second arg of TerminalTest is the winner

    # if the current board is a terminal state, return None for the move, the final score, and 1 for nodes generated
    if winner != '?': # checks winner since a 0 in first arg could be a tie
        return None, score, 1 # including terminal node in our count of nodes generated
   
    bestValue = -1*float("inf") # negative infinity since we are maximizing
    bestMove = None
    nodesGenerated = 0

    for i in range(len(current)):
        for j in range(len(current[0])):
            if current[i][j] == '-': # if the space is open
                current[i][j] = 'X' # make the move
                move, value, num = MinValue(current, prune, alpha, beta) # get the value of that move
                nodesGenerated += num # add the number of nodes generated by MinValue to our total
                current[i][j] = '-' # undo the move

                if value > bestValue: # if this move is better than our best move so far
                    bestValue = value
                    bestMove = (i,j)

                if prune: # if we are using alpha-beta pruning
                    alpha = max(alpha, bestValue) # update alpha
                    if beta <= alpha: # if we can prune
                        break
    return bestMove, bestValue, nodesGenerated

# Returns the best move for O, the value of that move, and the number of search nodes generated.
def MinValue(current, prune, alpha, beta):

    score = TerminalTest(current)[0] # first arg of TerminalTest is the score
    winner = TerminalTest(current)[1]  # second arg of TerminalTest is the winner

    # if the current board is a terminal state, return None for the move, the final score, and 1 for nodes generated
    if winner != '?': # checks winner since a 0 in first arg could be a tie
        return None, score, 1 

    bestValue = float("inf") # positive infinity since we are minimizing
    bestMove = None
    nodesGenerated = 0

    for i in range(len(current)):
        for j in range(len(current[0])):
            if current[i][j] == '-': # if the space is open
                current[i][j] = 'O' # make the move
                move, value, num = MaxValue(current, prune, alpha, beta) # get the value of that move
                nodesGenerated += num # add the number of nodes generated by MaxValue to our total
                current[i][j] = '-' # undo the move

                if value < bestValue: # if this move is better than our best move so far
                    bestValue = value
                    bestMove = (i,j)

                if prune: # if we are using alpha-beta pruning
                    beta = min(beta, bestValue) # update beta
                    if beta <= alpha: # if we can prune
                        break
    return bestMove, bestValue, nodesGenerated

# Returns the best move for O and the number of search nodes generated.
# board describes the state of the board
# prune is a boolean that indicates if alpha-beta
# pruning should be used.
def MinimaxDecision(board, prune):

    # makes a copy of the given board to pass to MinValue
    nextBoard = [row[:] for row in board]

    # MinValue returns three values (the nextmove, the minimax value, and nodes gneerated)
    # Can use _ to ignore values
    nextMove, _, nodesGenerated = MinValue(nextBoard, prune, -1*float("inf"), float("inf"))
    return nextMove,nodesGenerated


# Main program
##########################
def main():
    if len(sys.argv) != 2:
        print('Usage: python3 tictactoe.py [prune|noprune]')
    else:
        cmd = str(sys.argv[1])
        
        if(cmd != "prune" and cmd != "noprune"):
            print('Usage: python3 tictactoe.py [prune|noprune]')
            sys.exit()

        prune = str(sys.argv[1]) == "prune" 

        board = [['-','-','-'],
                 ['-','-','-'],
                 ['-','-','-']]

        winner = '?'
        while(winner == '?'):
            printBoard(board)
            usrMove = str(input('Please enter your move in the format 0,0: '))
            move = (int(usrMove[0]),int(usrMove[2]))
            if(board[move[0]][move[1]] != '-'):
                print("Illegal Move! Please choose an open space.")
                continue
            board[move[0]][move[1]] = 'X'

            nextMove,nodesGenerated = MinimaxDecision(board, prune)
            if nextMove is not None: # if there is a move to make
                board[nextMove[0]][nextMove[1]] = 'O' # make the move for O
            print(nodesGenerated)

            score,winner = TerminalTest(board)
            if winner != '?':
                break

        printBoard(board)
        print(winner+' wins!')
           
#Executes the main program.
if __name__ == "__main__":
    main()
